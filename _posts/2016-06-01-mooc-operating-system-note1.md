---
layout: post
title: "操作系统 课程笔记"
description: "MOOC Operating System note"
keywords: operating system, os, mooc
category: OperatingSystem
tags: [operating system, os]
---

# 并发与并行
并发是**一段时间**内多个任务， 并行是**某个时间点**上的多个任务，所以单核无法并行，但可以并发。

# 计算机发展

1. 早期纸带机，串行，单用户
2. CPU，内存增强-> 流水线化(批处理)，操作系统初步的形态，有了并发的特征
3. 内存进一步扩大，内存中可以放入多个程序，而不需要磁盘读入，减少IO-> 多道程序（当一个程序等待IO,中断通知操作系统，操作系统调度切换，执行另一个程序），CPU更有效利用(考虑如何让CPU尽可能忙)
4. 多道程序提高了CPU利用率，但用户交互不够好，因为一个程序执行时用户得等待，因为该程序抢占了所有CPU时间直到停止或等IO发送
中断信号，于是出现分时系统，由操作系统控制程序执行，超过限制时间(现代操作系统通常是千分之一秒)切换其他程序任务，
感官上好像每个程序（或用户）独占计算机。如何打断程序执行呢？答案是时钟，时钟定期产生中断。
5. 个人电脑系统，提高交互性，字符命令到GUI
6. 多核
7. 网络快速发展出现分布式操作系统（前端只是用户界面，后端执行计算，通过internet链接）为了应对分布式的发展。
应对1，通过internet的松，紧耦合系统，数据中心机器集群是紧耦合，操作系统考虑如何高效管理，数据中心与用户终端是松耦合，
考虑如何高效传输。发展中。。。
8. 未来： 物联网，云计算中心，从早期的一群人围着一个计算机，到一群计算机围着一个人服务。

# 架构发展

1. 早期DOS资源紧缺，单体设计，没有模块化，却不安全

2. Linux面向服务器，资源更好，采用模块化设计

3. 早期模块化，函数调用实现访问，当前学术界产生一个想法（类似微服务），让操作系统变得更加小巧，
调用采用类似消息传递的机制，松耦合实现，
操作系统更加容易扩展-> 微内核架构的设计，内核只放最基本的消息传递，中断处理。
而比如文件系统，内存管理等都放在外围作为进程(服务)形式存在。灵活且安全，代价是性能，目前产业界很少有微内核架构的设计。

4. 学术界另一个极端的想法是把硬件封装成一个lib，

5. 还出现了VM虚拟机


# 第三讲  启动、中断、异常和系统调用

操作系统保证系统安全以及衔接应用程序和外设，实现这一目的主要有三个方面：

1. 中断（外设）
2. 异常(应用程序的意外行为，如除零，如恶意访问其他程序地址空间，如请求内存占满)
3. 系统调用

处理时间：

1. 中断 ： 异步
2. 异常 ： 同步
3. 系统调用： 同步或异步

响应：

1. 中断： 持续，对应用程序透明
2. 异常： kill或重启应用程序
3. 系统调用： 等待或持续


## 3.1 BIOS

BIOS 加载 BootLoader(第一个扇区)， BootLoader 加载 OS

系统启动必须要找到一个特定的代码执行，此代码为BIOS，

BIOS 存储在内存的ROM段
系统启动开始时置CS:IP = 0xf000:fff0

系统处于实模式下, 此时：

**PC = 16*CS + IP**, 则PC= 0xffff0（共5*4 = 20位地址空间）

所以BIOS可得到约共20位地址空间（1MB）

### BIOS实现的功能
BIOS作为启动固件之用，那么首先需要有硬盘读写的能力以及其他包括：

* 基本输入输出程序（读写硬盘，键盘输入，屏幕输出）
* 系统设置信息(系统配置，例如从硬盘启动还是网络启动还是光盘启动，U盘启动)
* 开机后自检程序
* 系统自启动程序等

### 具体过程

#### 加载程序
将加载程序从磁盘的引导扇区（512字节）加载到0x7c00 (0111 1100 0000 0000)

（那么加载程序最大只有512字节）

跳转到 CS:IP = 0000:7c00

控制权转到此加载程序

加载程序功能：

* 将操作系统的代码和数据从硬盘加载到内存中
* 跳转到操作系统的起始地址（控制权交给了操作系统）

问题：
为什么需要一个 中间的加载程序加载操作系统，而不是BIOS直接把操作系统内核映像读进去呢？

答：首先磁盘上有各种格式的文件系统(NTFS，FAT32等)，那么识别文件系统格式可以由加载程序完成

#### BIOS系统调用
BIOS以中断方式提供基本的I/O功能，例如：

* INT 10h: 字符显示
* INT 13h: 磁盘扇区读写
* INT 15h: 检测内存大小
* INT 16h: 读取键盘输入

BIOS提供最简单最基本的IO功能，其使用也受到很大限制（例如对于x86,只能在实模式下访问）。

## 3.2 系统启动流程
参考：[计算机是如何启动的](http://www.ruanyifeng.com/blog/2013/02/booting.html)

### MBR格式
MBR共512字节，包括：

1. 启动代码: 1-446字节，共446字节（代码段）
2. 硬盘分区表: 447-510字节，共64字节（数据段）可用4分区，每分区16字节，猜测这意味着一个分区的寻址空间约2^128字节。
3. MBR结束标志：511-512字节，共2字节，0x55AA

在BIOS中不是有启动顺序么？比如U盘启动就将其顺序放置在第一位，

实际过程是按照启动顺序检查存储设备最前面的512字节，如果最后以0x55AA结尾，就认为是MBR（Master Boot Record,主引导记录）

MBR之后跳到分区引导扇区上，

分区引导扇区格式：

## 3.3 中断、异常和系统调用


# 实验部分
## 3-1 x86启动顺序

step1. 各寄存器初始化到初始值，关键注意CS和EIP的值，CS=F000H，EIP=0000FFF0H，Base=FFFF0000H

为了兼容早期的8086，初始启动为实模式，后续才到保护模式

### Bootloader做的事情

1. 使能保护模式（将特殊寄存器CR0从0置为1，从实模式切换到保护模式），段机制能正常工作了
2. 读取kernel代码（可能保存在多个扇区）到内存中固定的位置
3. 修改CS，EIP控制权转移给内核
4. 建立gdt（全局描述符表）结构

## 3-2 C函数调用的实现

